###一.主线

    1.java类及类的成员：属性，方法，构造器，代码块，内部类
    2.面向对象的三大特征：封装性，继承性，多态性（抽象性）
    3.其他关键字public，private，this，final，super，abstract，interface，import，static
    
    面向对象的两个要素
    类（class）：是对一类事物的描述，是抽象的、概念上的定义
    对象（object）：是实际存在的该类事物的每个个体，因而也称为实例（instance）
    
    如果创建了一个类的多个对象，则每一个对象都独立有一套类的属性（非static）
    
    对象的内存解析：
    堆（heap）：此内存区域的唯一目的就是存放对象实例
    栈（stack）：存储局部变量
    方法区（method area）：用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
    
    匿名对象的使用：
    1.huahua和grade1都不是匿名对象
    2.创建对象的时候没有取名字
    3.匿名对象只能使用一次
    4.使用：

###二.方法的重载（overload）

    方法的重载：
    1.定义：在同一个类中允许存在方法名相同但是传入参数不同的方法
    2.通过对象调用方法（方法名————>参数列表）

###三.可变个数的形参（varargs）

    可变个数的形参：
    1.JavaSE 5.0 中提供了varargs机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，
    来传递个数可变的实参
    2.public void test(String ... books)  和 public void test(String[] books)是一样的
    3.public void test(String ... books) 里依然是用数组来操作
    4.可变个数的形参必须是最后一个参数Vararg parameter must be the last in the list且最多只能声明一个可变个数的形参

###四.值得传递

    对于基本数据类型，n=m是重新拿出来一个地址给n，并且value是m的value,因此对n重新赋值时不会改变m的值
    对于引用型参数，由于将o1赋值给o2时，两者指向堆空间的同一个地址，因此对o2.idNumber进行重新赋值的时候o1.idNumber的值也会改变

###五.构造器

    类的结构之三：构造器（constructor）的使用：
    构造器的使用：
    1.创建对象
    2.初始化对象的信息
    说明：
    1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器
    2.定义构造器的格式：权限修饰符 类名(形参列表){}
    3.一个类中定义的多个构造器彼此之间构成重载
    4.一旦我们显示的定义了类的构造器之后，系统不再提供默认的空参构造器
    5.一个类中至少会有一个构造器

###六.JavaBean

    JavaBean是一种Java语言写成的可以重用组件
    所谓JavaBean是指符合以下标准的Java类：
    1.类是公共的
    2.有一个无参的公共的构造器
    3.有属性，且有对应的getter和setter方法
    用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP
    页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制粘贴的功能
    而不用关心任何改变

###七.UML图

          Bank                          //类名
    -customers:Customer[]               //-代表private，类型是Customer对象数组
    -numberOfCustomers:int
    +Bank()                             //无参构造器，+代表public
    +addCustomer(f:String,l:String)     //public方法，参数为两个String，名为f和l
    +getNumberOfCustomers():int         //public方法，无参，返回类型为int
    +getCustomer(index:int):Customer    // public方法，参数为int型的index，返回类型为Customer对象

###八.package关键字以及MVC设计模式

    一.package关键字的使用
        1.为了更好地实现项目中的类的管理，提供包的概念
        2.使用package声明类或接口所属的包，声明在源文件的首行
        3.包属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”
        4.名字中每  . 一次就代表一层目录
        补充：同一个包下不能命名重名的接口或者类
        java.lang--包含一些Java语言的核心类，比如String、Math、Integer、System和Thread，提供常用的功能
        java.net--包含执行与网络相关的操作的类和接口
        java.io--包含提供多种输入/输出功能的类
        java.util--包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数
        java.text--包含了一些Java格式化相关的类
        java.sql--包含了Java进行JDBC数据库编程的相关的类/接口
        java.awt--包含了抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI） B/S  C/S
    MVC设计模式：
        MVC是常用的设计模式之一，将整个程序分为三次层次：视图模型层，控制器层与数据模型层。这种将程序输入输出、数据处理，以及数据的展示
        分离开来的设计模式使程序结构变得灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。
        模型层：model 主要处理数据
            数据对象封装 model.bean/domain
            数据库操作 model.dao
            数据库 model.db
        控制层：controller 处理业务逻辑
            应用界面相关 controller.activity
            存放fragment controller.fragment
            显示列表的适配器 controller.adapter
            服务相关的 controller.service
            抽取的基类 controller.base
        视图层：view 显示数据
            相关工具类 view.utils
            自定义view view.ui

###九.import关键字

    import关键字的使用:
    import:导入
    1.在源文件中显示的使用import结构导入指定包下的类、接口
    2.声明在包的声明和类之间
    3.如果需要带入多个结构，则并列写出即可
    4.可以使用xxx.*的方式，表示导入包内的所有结构
    5.如果使用的类或接口是java.lang包的下定义的，则可以省略import结构

###十.继承性Inheritance

    extends关键字
        public class son extends father{
        }
    继承性的优点：
        1.减少了代码的重复，提高了代码的复用性
        2.便于功能的扩展
        3.为之后多态的使用，提供了前提
    格式：
        class A extends B{}
        A：子类、派生类、subclass
        B：父类、超类、基类、superclass
        子类A继承父类B后，子类就获取了父类中的结构：属性和方法
        1.特别的，父类中的声明为private类型的属性和方法，子类继承父类后，任然认为继承了父类中的私有的结构
        只是因为封装性的影响，使得子类不能直接调用父类的结构
        2.子类继承父类以后还可以声明自己特有的属性和方法：实现功能的扩展，子类和父类的关系不是子集和集合的关系
    java中关于继承性的规定：
        1.java只支持单继承和多层继承：不允许多重继承
            一个子类只能有一个父类
            一个父类可以派生出多个子类
    Object类
        所有的java类除Object（java.lang）外,都直接或间接继承Object类
    子类对象实例化的过程：
        1.从结果上看：（继承性）
            子类继承父类以后，就获取了父类中声明的属性或方法
            创建子类的对象，在堆空间中就会加载所有父类中声明的属性
        2.从过程上来看：
            当我们通过子类的构造器创建子类对象时，我们一定会直接或间接调用其父类的构造器，进而调用父类的父类的构造器，
            直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类
            的结构，子类对象才可以考虑进行调用。
    明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象

###十一.重写Override

    定义：
        在子类当中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在执行程序的时候，子类的方法覆盖父类的方法
    要求：
        1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
        2.子类重写的方法返回值类型不能大于父类被重写的方法返回值类型
        3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
            子类不能重写父类中声明为private权限的方法
        4.子类方法抛出的异常不能大于父类被重写方法的异常
            4.1 try-catch父类的异常类型，子类异常类型小于父类，则try-catch一定可以处理
    注意：
        子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static的（不是重写）。
        因为static方法属于类的，子类无法覆盖父类的方法。

###十二.super关键字

    super关键字的使用：
        1.父类子类的同名属性或子类重写的父类方法:
        super.属性来调用父类的属性，super是直接去父类找
        this.属性 表示调用自己类的属性，this是现在自己的类中找，没有的话再去父类找
        2.调用父类的构造器super(参数，参数)
    必须声明在子类构造器的首行
    在类的构造器中，this(形参list)和super(形参list)两者只能选一个
    当两个都不用的时候，默认super()

###十三.多态性Polymorphism

    面向对象的特征三：多态性
        1.可以理解为一个事物的多种形态
        Person p = new Man();
        对象的多态性:父类的引用指向子类的对象
    多态的使用：
        当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法————虚拟方法调用
        编译的时候认为是父类的方法，所以不能在编译时调用子类特有的方法
        执行的时候认为是子类的方法
    多态性的使用前提：
        类的继承关系
        方法的重写
    对象的多态性：
        只适用于方法，不适用于属性
    向下转型：转换时可能会出现异常
        父类----------------------------->子类
           向下转型，使用instanceof进行判断
        父类<-----------------------------子类
           向上转型：多态
    instanceof关键字的使用：
        为了避免在向下转型的时候出现ClassCastException的异常，在转型前需要用instanceof判断一下
        a instanceof A:判断对象a是否是类A 的实例，如果是返回true，如果不是返回false
        类B是类A的父类，如果 a instanceof A返回true，那么 a instanceof B 也返回true

###十四.Object类以及“==”和equals()的区别

    java.lang包下的Object类：
        通过以下语句可以获得oder的父类
        order.getClass().getSuperclass()
    ==和equals()的区别：
        ==是运算符
        1. 可以使用在基本数据类型变量和引用数据类型变量中
        2. 如果是基本数据类型，那么就是比较两个变量储存的数据是否相等
        3. 如果比较的是引用数据类型，那么是比较两个引用数据类型的地址值是否相同
        equals()是方法
        1. equals()只能适用于引用数据类型
        2. Object类中定义的equals()和==相同，也就是比较两个对象的地址值
        public boolean equals(Object obj) {
                return (this == obj);
            }
        3. 像String、Data、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用地址是否相同
           而是比较两个对象的“实体内容”是否相同
    toString()的使用
        Object里的toString():
        1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
        public String toString() {
                return getClass().getName() + "@" + Integer.toHexString(hashCode());
            }
        2. 像String、Data、File、包装类等都重写了toString()方法
           使得在调用对象的toString()方法时返回“实体信息”的内容

###十五.JUbittest

    java中的单元测试
        1.创建java类，进行单元测试
        2.此类是public的，此类提供公共的无参构造器
        3.此类中声明单元测试方法
            此时的单元测试方法：权限是public，没有返回值，没有形参
        4.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入 org.testng.annotations.Test;
        5.声明好单元测试方法以后，就可以在方法体内测试相关的代码
        6.写完代码后，左键双击单元测试方法名，右键run as-junit
    说明：
        1. 如果执行过程中没有问题，那么是绿条反之红条

十六.包装类Wrapper

    基本数据类型          包装类
    byte     ---------- Byte
    short    ---------- Short
    int      ---------- Integer
    long     ---------- Long
    float    ---------- Float
    double   ---------- Double
    boolean  ---------- Boolean
    char     ---------- Character

###十七.static关键字

    static可以用来修饰属性、方法、代码块、内部类
        当所有的对象都共享一个相同的属性的时候，例如所有中国人的country都是China
        类中static修饰的属性不归属与对象，而是所有对象共享的
    静态变量可以通过类.变量名来调用
        静态方法中只能调用静态属性或方法
        非静态的方法中，既可以调用静态的属性和方法，也可以调用非静态的
    静态方法中不可以使用this和super关键字
    >操作静态属性的方法，通常设置为static
    >工具类中的方法，习惯上声明为static。比如：Math、Arrays、Collections

###十八.单例模式

    单例（Singleton）设计模式：
    设计模式：
        是大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。
    类的单例设计模式：
        就是采用一定的方法保证在整个的软件系统中，对某个类*只能存在一个对象实例*，并且该类只提供一个取得其对象实例的方法。如果我们
        要让类在虚拟机中只产生一个对象：
            将类的构造器的访问权限设置为private，这样就不能用new操作符在类的外部产生类的对象，但在类内部仍可以产生该类的对象
            调用类的某个静态方法以返回类内部创建的对象
            该类对象的变量也必须定义为静态的
    单例模式的懒汉式和饿汉式：
        饿汉式：在类中直接创建好类，坏处：对象加载时间过长，好处：线程安全
        懒汉式：用的时候再造对象，好处：节省内存空间，坏处：目前的写法，线程可能出错
    单例模式的使用场景：
        网站的计数器
        应用程序的日志应用
        数据库连接池
        项目中读取配置文件的类
        Application也是单例的典型应用
        Windows的Task Manager（任务管理器）
        Windows的Recycle Bin（回收站）
    book--《大话设计模式》
        创建型模式：
            工厂方法模式
            抽象工厂模式
            单例模式
            建造者模式
            原型模式
        结构型模式：
            适配器模式
            装饰器模式
            代理模式
            外观模式
            桥接模式
            组合模式
            享元模式
        行为型模式：
            策略模式
            模板方法模式
            观察者模式
            迭代子模式
            责任链模式
            命令模式
            备忘录模式
            状态模式
            访问者模式
            中介者模式
            解释器模式

###十九.代码块Block

    代码块（或初始化块）
        1.代码块的作用：用来初始化类、对象
        2.代码块如果有修饰的话，只能使用static
        3.静态代码块 vs 静态代码块
        静态代码块：
            >内部可以有输出语句
            >随着类的加载而执行,只执行一次
            >不可以调用非静态的结构
        非静态代码块：
            >内部可以有输出语句
            >随着对象的创建而执行
            >初始化对象
            >可以调用非静态的结构
    
    对属性可以赋值的位置：
        1.默认初始化
        2.显示初始化
        3.构造器中初始化
        4.有了对象后可以用 对象.属性 或 对象.方法
        5.在代码块中赋值
        执行的先后顺序：1--2--3/5--4

###二十.final关键字

    final:最终的,可以用来修饰类、方法、变量
        final用来修饰一个类，表明这个类不能被继承（比如String类、System类、StringBuffer）
        final用来修饰一个方法，表明这个方法不能被重写（比如Object类中getClass()）
        final用来修饰一个变量，说明这个变量就称为一个常量，不能再做改变
                final若用来修饰属性，可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化
                final修饰局部变量
                    尤其是使用final修饰形参时，表明此形参是一个常量，也就是说在调用方法时给形参赋一个实参，
                    在方法内不可以对该形参进行赋值和修改
    static final 用来修饰属性、方法
        属性：全局变量
        方法：这个方法只能在内部调，不能被重写

###二十一.abstract关键字

    抽象类（abstract）：
        随着继承层次中一个个新子类的定义，类变得越来越一般，更通用。类的设计应该保证父类和子类能够共享特征。
        有时将一个父类设计的非常抽象，以至于他没有具体的实例，这样的类叫做抽象类
    abstract修饰一个类表明这个类为抽象类
        >不能创建此类的对象
        >类中仍然有构造器
        >实际工作中会提供抽象类的子类
    abstract修饰一个方法表明这个方法为抽象方法
        >抽象方法没有方法体 public abstract void eat();
        >包含抽象方法的类一定是个抽象类
        >若子类重写了父类中所有的抽象方法后，子类才可以实例化，若没有，则此子类也是一个抽象类，需要使用abstract修饰
    abstract的使用情景：
        >用于提醒子类需要重写方法
    abstract的使用上的注意点：
        >不能用来修饰属性和构造器
        >不能用来修饰私有方法、静态方法
    抽象类的匿名子类的使用：
        >

###二十二.模板设计模式Template

    TemplateMethod模板方法设计模式：
        抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类
        总体上会保留抽象类的行为模式。
    解决的问题：
        1.当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现
        2.换句话说，在软件开发中实现一个算法时，整体步骤是很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分
        可以抽象出来，供子类实现。这就是一种模板模式

###二十三.接口

    接口：
        1.一方面，有时需要从几个类中派生出一个类，继承他们所有的属性和方法。但是，java不支持多重继承。有了接口就可以得到多重继承的效果
        2.另一方面，有时需要从几个类中抽取出一些共同的行为特征，而他们之间有没有is-a（父子类）的关系，仅仅是几个相同的行为特征而已。例如鼠标、键盘、
        打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB链接
        3.接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要···则必须能···”的思想。继承是一个“是不是”的关系，而接口实现的是
        “能不能”的关系
        4.接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守
    接口的使用：
        1. 接口使用interface来定义
        2. Java中，接口和类是并列的两个结构
        3. 如何定义接口：定义接口中的成员
            3.1 JDK7及以前：只能定义全局常量和抽象方法
                >全局常量：public static final的（可以省略不写）
                >抽象方法：public abstract的
            3.2JDK8：
                除了定义全局常量和抽象方法以外，还可以定义静态方法、默认方法
                静态方法：接口中定义的静态方法只能通过接口来调用，不能通过实现类对象来调用（C26_JDK8_Interface.Method1）
                默认方法：可以通过实现类创建的对象调用，如果实现类重写了接口中的方法，调用的时候调用的是重写后的方法
                注意：
                    1. 如果子类（实现类）继承了父类，父类中有方法和接口中重名并且子类（实现类）没有重写该方法，会调用父类的方法-->类优先原则
                    2. 如果实现类继承的多个接口中有同名同参数的方法，并且实现类没有重写此方法，则编译报错---->接口冲突，因此需要我们重写此方法
        4.接口中不能定义构造器，接口不可以实例化
        5.Java开发中，我们都是用类来实现接口 class B implements interface
          类链接接口后必须把所有的抽象方法重写后才能实例化
          允许多个接口：用 , 隔开--->弥补了Java不可以一次性继承多个父类的局限
        6.接口和接口之间也可以继承，可以多个继承
        7.接口的使用可以体现多态性
        8.接口实际上可以看做是一种规范
        9.如果既要继承类又要引用接口，先extends后implements

###二十四.代理模式Proxy

    代理模式（Proxy）：
        1. 概述
           代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问
           代理类ProxyInterface<------接口------>InterfaceImpl被代理类
        2. 应用
           安全代理：屏蔽对真实对象的直接访问
           远程代理：通过代理类处理远程方法调用(RMI)
           延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象
           静态代理：静态定义代理类
           动态代理：动态定义代理类
               JDK自带的动态代理，需要反射等知识

###二十五.内部类Inner class

    内部类：
    一.概述
          当一个事物内部，还有一个部分需要一个完整的结构来描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整的结构最好使用内部类
          在Java中，允许一个类的定义在另一个类的内部，前者称为内部类，后者称为外部类
          Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称，Inner class的名字不能与包含它的外部类类名相同
    二.分类
          成员内部类（static成员内部类和非static成员内部类）
          局部内部类(方法内、代码块内、构造器内)（不谈修饰符）、匿名内部类
    三.特点
          成员内部类
             一方面，作为外部类的成员：
                  > 可以调用外部类的结构
                  > 可以被static修饰
                  > 可以被四种不同的权限修饰
             另一方面，作为一个类
                  > 类内可以定义属性、方法、构造器、内部类等
                  > 可以继承/被继承，可以被final修饰
                  > 可以被abstract修饰
    四.3个问题
          4.1 如何实例化内部类的对象
              静态成员内部类：外部类.静态成员内部类 对象名 = new 外部类.静态成员内部类();
              非静态成员内部类：先创建外部类的对象，外部类对象.非静态成员内部类来创建非静态成员内部类
                  human h = new human();
                  human.property pro = h.new property();
          4.2 如何在成员内部类中区分调用外部类机构
              方法的形参：  System.out.println(name);
              内部类的属性：System.out.println(this.name);
              外部内的属性：System.out.println(human.this.name);
          4.3 开发中局部内部类的使用情景
              创建一个有名的接口类